runExample("03_reactivity") # a reactive expression
ggplot(presidentialForecast)
?data.frame()
?ggplot
df <- data.frame(x=rep(1:5, 9), val=sample(1:100, 45),
variable=rep(paste0("category", 1:9), each=5))
# plot
ggplot(data = df, aes(x=x, y=val)) + geom_line(aes(colour=variable))
runExample("03_reactivity") # a reactive expression
View(df)
?geom_line
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Presidential Forecasts"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Include clarifying text ----
helpText("Note: Here are the results from presidential forecasts from 1952-2008."),
# Input: actionButton() to defer the rendering of output ----
# until the user explicitly clicks the button (rather than
# doing it immediately when inputs change). This is useful if
# the computations required to render output are inordinately
# time-consuming.
selectInput(inputId = "forecaster",
label = "Choose a forecast:",
choices = colnames(presidentialForecast),
multiple = TRUE)
),
# Main panel for displaying outputs ----
mainPanel(
tableOutput("view"),
tableOutput("viewForecastSelection"),
plotOutput(outputId = "resultPlot")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
#  datasetInput <- reactive({
#   switch(input$forecaster,
#           "Cambell" = presidentialForecast$Campbell,
#           "Lewis-Beck" = presidentialForecast$Lewis-Beck,
#           "EWT2C2" = presidentialForecast$EWT2C2,
#           "Fair" = presidentialForecast$Fair,
#           "Hibbs" = presidentialForecast$Hibbs,
#           "Abramowitz" = presidentialForecast$Abramowitz,
#           "Actual" = presidentialForecast$Actual)
#  })
plotDataFrame <- input$forecaster
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
output$viewForecastSelection <- renderTable({
plotDataFrame
})
}
# Create Shiny app ----
shinyApp(ui, server)
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Presidential Forecasts"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Include clarifying text ----
helpText("Note: Here are the results from presidential forecasts from 1952-2008."),
# Input: actionButton() to defer the rendering of output ----
# until the user explicitly clicks the button (rather than
# doing it immediately when inputs change). This is useful if
# the computations required to render output are inordinately
# time-consuming.
selectInput(inputId = "forecaster",
label = "Choose a forecast:",
choices = colnames(presidentialForecast),
multiple = TRUE)
),
# Main panel for displaying outputs ----
mainPanel(
tableOutput("view"),
#tableOutput("viewForecastSelection"),
plotOutput(outputId = "resultPlot")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
#  datasetInput <- reactive({
#   switch(input$forecaster,
#           "Cambell" = presidentialForecast$Campbell,
#           "Lewis-Beck" = presidentialForecast$Lewis-Beck,
#           "EWT2C2" = presidentialForecast$EWT2C2,
#           "Fair" = presidentialForecast$Fair,
#           "Hibbs" = presidentialForecast$Hibbs,
#           "Abramowitz" = presidentialForecast$Abramowitz,
#           "Actual" = presidentialForecast$Actual)
#  })
plotDataFrame <- input$forecaster
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
#output$viewForecastSelection <- renderTable({
#  plotDataFrame
#})
}
# Create Shiny app ----
shinyApp(ui, server)
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Presidential Forecasts"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Include clarifying text ----
helpText("Note: Here are the results from presidential forecasts from 1952-2008."),
# Input: actionButton() to defer the rendering of output ----
# until the user explicitly clicks the button (rather than
# doing it immediately when inputs change). This is useful if
# the computations required to render output are inordinately
# time-consuming.
selectInput(inputId = "forecaster",
label = "Choose a forecast:",
choices = colnames(presidentialForecast),
multiple = TRUE)
),
# Main panel for displaying outputs ----
mainPanel(
tableOutput("view"),
#tableOutput("viewForecastSelection"),
plotOutput(outputId = "resultPlot")
)
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
#  datasetInput <- reactive({
#   switch(input$forecaster,
#           "Cambell" = presidentialForecast$Campbell,
#           "Lewis-Beck" = presidentialForecast$Lewis-Beck,
#           "EWT2C2" = presidentialForecast$EWT2C2,
#           "Fair" = presidentialForecast$Fair,
#           "Hibbs" = presidentialForecast$Hibbs,
#           "Abramowitz" = presidentialForecast$Abramowitz,
#           "Actual" = presidentialForecast$Actual)
#  })
#plotDataFrame <- input$forecaster
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
#output$viewForecastSelection <- renderTable({
#  plotDataFrame
#})
}
# Create Shiny app ----
shinyApp(ui, server)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
#  datasetInput <- reactive({
#   switch(input$forecaster,
#           "Cambell" = presidentialForecast$Campbell,
#           "Lewis-Beck" = presidentialForecast$Lewis-Beck,
#           "EWT2C2" = presidentialForecast$EWT2C2,
#           "Fair" = presidentialForecast$Fair,
#           "Hibbs" = presidentialForecast$Hibbs,
#           "Abramowitz" = presidentialForecast$Abramowitz,
#           "Actual" = presidentialForecast$Actual)
#  })
data.frame(input$forecaster)
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
#output$viewForecastSelection <- renderTable({
#  plotDataFrame
#})
}
# Create Shiny app ----
shinyApp(ui, server)
?selectInput
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
#  datasetInput <- reactive({
#   switch(input$forecaster,
#           "Cambell" = presidentialForecast$Campbell,
#           "Lewis-Beck" = presidentialForecast$Lewis-Beck,
#           "EWT2C2" = presidentialForecast$EWT2C2,
#           "Fair" = presidentialForecast$Fair,
#           "Hibbs" = presidentialForecast$Hibbs,
#           "Abramowitz" = presidentialForecast$Abramowitz,
#           "Actual" = presidentialForecast$Actual)
#  })
input$forecaster
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
#output$viewForecastSelection <- renderTable({
#  plotDataFrame
#})
}
# Create Shiny app ----
shinyApp(ui, server)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
input$forecaster
#  datasetInput <- reactive({
#   switch(input$forecaster,
#           "Cambell" = presidentialForecast$Campbell,
#           "Lewis-Beck" = presidentialForecast$Lewis-Beck,
#           "EWT2C2" = presidentialForecast$EWT2C2,
#           "Fair" = presidentialForecast$Fair,
#           "Hibbs" = presidentialForecast$Hibbs,
#           "Abramowitz" = presidentialForecast$Abramowitz,
#           "Actual" = presidentialForecast$Actual)
#  })
input$forecaster
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
#output$viewForecastSelection <- renderTable({
#  plotDataFrame
#})
}
# Create Shiny app ----
shinyApp(ui, server)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
input$forecaster
#  datasetInput <- reactive({
#   switch(input$forecaster,
#           "Cambell" = presidentialForecast$Campbell,
#           "Lewis-Beck" = presidentialForecast$Lewis-Beck,
#           "EWT2C2" = presidentialForecast$EWT2C2,
#           "Fair" = presidentialForecast$Fair,
#           "Hibbs" = presidentialForecast$Hibbs,
#           "Abramowitz" = presidentialForecast$Abramowitz,
#           "Actual" = presidentialForecast$Actual)
#  })
test <- presidentialForecast[,c(input$forecaster)]
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
#output$viewForecastSelection <- renderTable({
#  plotDataFrame
#})
}
# Create Shiny app ----
shinyApp(ui, server)
server
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
input$forecaster
#  datasetInput <- reactive({
#   switch(input$forecaster,
#           "Cambell" = presidentialForecast$Campbell,
#           "Lewis-Beck" = presidentialForecast$Lewis-Beck,
#           "EWT2C2" = presidentialForecast$EWT2C2,
#           "Fair" = presidentialForecast$Fair,
#           "Hibbs" = presidentialForecast$Hibbs,
#           "Abramowitz" = presidentialForecast$Abramowitz,
#           "Actual" = presidentialForecast$Actual)
#  })
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
test <- presidentialForecast[,c(input$forecaster)]
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
#output$viewForecastSelection <- renderTable({
#  plotDataFrame
#})
}
# Create Shiny app ----
shinyApp(ui, server)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
input$forecaster
#  datasetInput <- reactive({
#   switch(input$forecaster,
#           "Cambell" = presidentialForecast$Campbell,
#           "Lewis-Beck" = presidentialForecast$Lewis-Beck,
#           "EWT2C2" = presidentialForecast$EWT2C2,
#           "Fair" = presidentialForecast$Fair,
#           "Hibbs" = presidentialForecast$Hibbs,
#           "Abramowitz" = presidentialForecast$Abramowitz,
#           "Actual" = presidentialForecast$Actual)
#  })
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
#test <- presidentialForecast[,c(input$forecaster)]
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
#output$viewForecastSelection <- renderTable({
#  plotDataFrame
#})
}
# Define server logic to summarize and view selected dataset ----
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
#presidentialForecast$year <- rownames(presidentialForecast)
#presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
test <- presidentialForecast[,c(input$forecaster)]
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
}
# Create Shiny app ----
shinyApp(ui, server)
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
test <- presidentialForecast[,c(input$forecaster)]
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = plotDataFrame, aes()) + geom_line()
})
}
# Create Shiny app ----
shinyApp(ui, server)
View(df)
View(presidentialForecast)
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
test <- presidentialForecast[,c(input$forecaster)]
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = test, x = test$year, y = test$Actual)
})
output$viewForecastSelection <- renderTable({
test <- presidentialForecast[,c(input$forecaster)]
test
})
}
# Define UI for dataset viewer app ----
ui <- fluidPage(
# App title ----
titlePanel("Presidential Forecasts"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Include clarifying text ----
helpText("Note: Here are the results from presidential forecasts from 1952-2008."),
# Input: actionButton() to defer the rendering of output ----
# until the user explicitly clicks the button (rather than
# doing it immediately when inputs change). This is useful if
# the computations required to render output are inordinately
# time-consuming.
selectInput(inputId = "forecaster",
label = "Choose a forecast:",
choices = colnames(presidentialForecast),
multiple = TRUE)
),
# Main panel for displaying outputs ----
mainPanel(
tableOutput("view"),
tableOutput("viewForecastSelection"),
plotOutput(outputId = "resultPlot")
)
)
)
# Create Shiny app ----
shinyApp(ui, server)
server <- function(input, output) {
library(EBMAforecast)
data("presidentialForecast")
presidentialForecast$year <- rownames(presidentialForecast)
presidentialForecast$year <- as.numeric(presidentialForecast$year)
output$view <- renderTable({
presidentialForecast
})
output$resultPlot <- renderPlot({
test <- presidentialForecast[,c(input$forecaster)]
plot(presidentialForecast$year,presidentialForecast$Actual, type = "l", main = "Presidential Election Results", xlab = "year", ylab = "percentage of something")
#ggplot(data = test, x = test$year, y = test$Actual)
})
output$viewForecastSelection <- renderTable({
test <- presidentialForecast[,c(input$forecaster)]
as.dataframe(test)
})
}
# Create Shiny app ----
shinyApp(ui, server)
#install.packages("RSQLite")
install.packages("sqldf")
install.packages("XLConnect")
library(sqldf)
setwd("C:/Users/aaron/OneDrive/Documents/Applied Statistical Programming/MayoralTwitterData")
sqlite <- dbDriver("SQLite")
?dbDriver
db <- dbConnect(SQLite(), "mayoralTwitterData.db")
library(DBI)
db <- dbConnect(SQLite(), "mayoralTwitterData.db")
db <- dbConnect(RSQLite::SQLite(), "mayoralTwitterData.db")
dbSendQuery(conn = db, "CREATE TABLE School (SchID Integer, Location TEXT, Authority Text, SchSize TEXT")
userTable <- function(userHandles){
ut <- (twListToDF(lookupUsers(userHandles)))
ut$followRequestSent <- NULL
return(ut)
}
mayoralHandles[1:10]
library(twitteR)
setup_twitter_oauth(consumerKey, consumerSecret)
mayoralData$Twitter_handle[1:10]
createProfile10 <- sapply(mayoralHandles[1:10], createProfile)
createProfile <- function(handle){
user <- NULL
user$userInfo <- userTable(handle)
user$tweets <- twitterStatusDF(handle)
user$mentions <- statusCollectorST(handle)
return(user)
}
createProfile10 <- sapply(mayoralHandles[1:10], createProfile)
load("UT10.rda")
dbWriteTable(db, "handleData", UT10)
dbListTables(db)
?dbWriteTable
?dbGetQuery
UT10$key <- 1:length(UT10$description)
UT10
dbWriteTable(db, "handleData", UT10)
dbWriteTable(db, "handleData", UT10)
dbWriteTable(db, "handleData", UT10)
